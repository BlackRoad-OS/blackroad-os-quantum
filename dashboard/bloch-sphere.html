<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚öõÔ∏èüòâ Bloch Sphere - BlackRoad Quantum</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --black: #000000;
            --white: #FFFFFF;
            --amber: #F5A623;
            --hot-pink: #FF1D6C;
            --electric-blue: #2979FF;
            --violet: #9C27B0;
            --green: #00FF88;

            --gradient-brand: linear-gradient(135deg,
                var(--amber) 0%,
                var(--hot-pink) 38.2%,
                var(--violet) 61.8%,
                var(--electric-blue) 100%);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', sans-serif;
            background: var(--black);
            color: var(--white);
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .canvas-container {
            flex: 1;
            position: relative;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .controls {
            width: 350px;
            background: rgba(0, 0, 0, 0.9);
            border-left: 2px solid var(--hot-pink);
            padding: 34px;
            overflow-y: auto;
        }

        h1 {
            font-size: 34px;
            background: var(--gradient-brand);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 21px;
        }

        .section {
            margin-bottom: 34px;
        }

        .section-title {
            font-size: 16px;
            color: var(--hot-pink);
            margin-bottom: 13px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 13px;
        }

        button {
            padding: 13px;
            background: rgba(255, 29, 108, 0.1);
            border: 1px solid var(--hot-pink);
            border-radius: 8px;
            color: var(--white);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        button:hover {
            background: var(--hot-pink);
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 29, 108, 0.5);
        }

        button.active {
            background: var(--hot-pink);
            box-shadow: 0 0 20px rgba(255, 29, 108, 0.8);
        }

        .slider-group {
            margin-bottom: 21px;
        }

        .slider-label {
            font-size: 13px;
            color: var(--amber);
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 21px;
            height: 21px;
            background: var(--hot-pink);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 13px rgba(255, 29, 108, 0.8);
        }

        input[type="range"]::-moz-range-thumb {
            width: 21px;
            height: 21px;
            background: var(--hot-pink);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 13px rgba(255, 29, 108, 0.8);
        }

        .state-display {
            background: rgba(255, 29, 108, 0.1);
            border: 1px solid var(--hot-pink);
            border-radius: 8px;
            padding: 13px;
            margin-top: 13px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .state-row {
            margin: 5px 0;
            color: var(--green);
        }

        .info {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 8px;
            line-height: 1.5;
        }

        .wink {
            font-size: 55px;
            text-align: center;
            animation: wink 3s ease-in-out infinite;
        }

        @keyframes wink {
            0%, 90%, 100% { content: 'üòâ'; }
            95% { content: 'üòä'; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="canvas-container">
            <canvas id="blochCanvas"></canvas>
        </div>

        <div class="controls">
            <div class="wink">üòâ</div>
            <h1>Bloch Sphere</h1>

            <div class="section">
                <div class="section-title">Quantum Gates</div>
                <div class="button-group">
                    <button onclick="applyGate('X')">X Gate</button>
                    <button onclick="applyGate('Y')">Y Gate</button>
                    <button onclick="applyGate('Z')">Z Gate</button>
                    <button onclick="applyGate('H')">Hadamard</button>
                </div>
                <div class="button-group">
                    <button onclick="applyGate('S')">S Gate</button>
                    <button onclick="applyGate('T')">T Gate</button>
                    <button onclick="applyGate('RX')">Rx(œÄ/4)</button>
                    <button onclick="applyGate('RY')">Ry(œÄ/4)</button>
                </div>
            </div>

            <div class="section">
                <div class="section-title">Common States</div>
                <div class="button-group">
                    <button onclick="setState(0, 0)">|0‚ü©</button>
                    <button onclick="setState(Math.PI, 0)">|1‚ü©</button>
                    <button onclick="setState(Math.PI/2, 0)">|+‚ü©</button>
                    <button onclick="setState(Math.PI/2, Math.PI)">|-‚ü©</button>
                </div>
                <div class="button-group">
                    <button onclick="setState(Math.PI/2, Math.PI/2)">|i‚ü©</button>
                    <button onclick="setState(Math.PI/2, -Math.PI/2)">|-i‚ü©</button>
                </div>
            </div>

            <div class="section">
                <div class="section-title">Custom State</div>
                <div class="slider-group">
                    <div class="slider-label">
                        <span>Œ∏ (theta)</span>
                        <span id="thetaValue">1.57</span>
                    </div>
                    <input type="range" id="theta" min="0" max="3.14159" step="0.01" value="1.57" oninput="updateState()">
                </div>
                <div class="slider-group">
                    <div class="slider-label">
                        <span>œÜ (phi)</span>
                        <span id="phiValue">0.00</span>
                    </div>
                    <input type="range" id="phi" min="0" max="6.28318" step="0.01" value="0" oninput="updateState()">
                </div>
            </div>

            <div class="section">
                <div class="section-title">Animation</div>
                <div class="button-group">
                    <button onclick="toggleRotation()">Rotate Sphere</button>
                    <button onclick="animate('orbit')">Orbit State</button>
                    <button onclick="animate('wiggle')">Wiggle üòâ</button>
                    <button onclick="animate('random')">Random Walk</button>
                </div>
            </div>

            <div class="state-display">
                <div class="state-row">|œà‚ü© = <span id="alpha">0.707|0‚ü©</span> + <span id="beta">0.707|1‚ü©</span></div>
                <div class="state-row">Œ∏ = <span id="thetaDisplay">œÄ/2</span></div>
                <div class="state-row">œÜ = <span id="phiDisplay">0</span></div>
                <div class="info">
                    Bloch sphere represents single qubit states in 3D.
                    |0‚ü© at north pole, |1‚ü© at south pole.
                    Superposition states on the sphere surface.
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('blochCanvas');
        const ctx = canvas.getContext('2d');

        let width, height, centerX, centerY, radius;
        let theta = Math.PI / 2;  // polar angle
        let phi = 0;               // azimuthal angle
        let rotation = 0;
        let autoRotate = false;
        let animationMode = null;
        let animationTime = 0;

        function resizeCanvas() {
            width = canvas.width = canvas.offsetWidth;
            height = canvas.height = canvas.offsetHeight;
            centerX = width / 2;
            centerY = height / 2;
            radius = Math.min(width, height) / 3;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function drawSphere() {
            // Clear
            ctx.clearRect(0, 0, width, height);

            // Background gradient
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius * 2);
            gradient.addColorStop(0, 'rgba(255, 29, 108, 0.05)');
            gradient.addColorStop(0.5, 'rgba(156, 39, 176, 0.05)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);

            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(rotation);

            // Draw sphere outline
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.stroke();

            // Draw equator
            ctx.strokeStyle = 'rgba(41, 121, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.ellipse(0, 0, radius, radius * 0.3, 0, 0, Math.PI * 2);
            ctx.stroke();

            // Draw meridians
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 6) * i;
                ctx.save();
                ctx.rotate(angle);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.beginPath();
                ctx.ellipse(0, 0, radius * 0.3, radius, 0, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }

            // Draw axes
            ctx.strokeStyle = 'rgba(245, 166, 35, 0.8)';
            ctx.lineWidth = 2;

            // X axis
            ctx.beginPath();
            ctx.moveTo(-radius * 1.2, 0);
            ctx.lineTo(radius * 1.2, 0);
            ctx.stroke();
            ctx.fillStyle = 'rgba(245, 166, 35, 0.8)';
            ctx.font = '16px SF Pro Display';
            ctx.fillText('X', radius * 1.3, 5);

            // Y axis
            ctx.beginPath();
            ctx.moveTo(0, -radius * 1.2);
            ctx.lineTo(0, radius * 1.2);
            ctx.stroke();
            ctx.fillText('Y', 5, -radius * 1.25);

            // Z axis (through rotation)
            ctx.save();
            ctx.rotate(-Math.PI / 4);
            ctx.beginPath();
            ctx.moveTo(-radius * 0.8, 0);
            ctx.lineTo(radius * 0.8, 0);
            ctx.stroke();
            ctx.restore();

            // Labels
            ctx.fillStyle = '#00FF88';
            ctx.font = 'bold 20px SF Pro Display';
            ctx.fillText('|0‚ü©', -15, -radius - 10);
            ctx.fillText('|1‚ü©', -15, radius + 25);

            // Draw state vector
            const x = radius * Math.sin(theta) * Math.cos(phi);
            const y = radius * Math.sin(theta) * Math.sin(phi);
            const z = -radius * Math.cos(theta);

            // Project 3D point to 2D (simple orthographic)
            const screenX = x;
            const screenY = z;

            // Vector from origin
            const vectorGradient = ctx.createLinearGradient(0, 0, screenX, screenY);
            vectorGradient.addColorStop(0, '#FF1D6C');
            vectorGradient.addColorStop(1, '#2979FF');

            ctx.strokeStyle = vectorGradient;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(screenX, screenY);
            ctx.stroke();

            // State point
            const pointGradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, 20);
            pointGradient.addColorStop(0, '#FF1D6C');
            pointGradient.addColorStop(1, 'rgba(255, 29, 108, 0)');

            ctx.fillStyle = pointGradient;
            ctx.beginPath();
            ctx.arc(screenX, screenY, 20, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#FF1D6C';
            ctx.beginPath();
            ctx.arc(screenX, screenY, 8, 0, Math.PI * 2);
            ctx.fill();

            // Draw trail (if animating)
            if (animationMode) {
                ctx.strokeStyle = 'rgba(255, 29, 108, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                // Draw previous positions as trail
                ctx.stroke();
            }

            ctx.restore();
        }

        function updateState() {
            theta = parseFloat(document.getElementById('theta').value);
            phi = parseFloat(document.getElementById('phi').value);

            document.getElementById('thetaValue').textContent = theta.toFixed(2);
            document.getElementById('phiValue').textContent = phi.toFixed(2);

            updateDisplay();
            drawSphere();
        }

        function updateDisplay() {
            // Calculate state vector coefficients
            const alpha = Math.cos(theta / 2);
            const beta = Math.exp(new Complex(0, phi)).mult(Math.sin(theta / 2));

            document.getElementById('alpha').textContent =
                `${alpha.toFixed(3)}|0‚ü©`;
            document.getElementById('beta').textContent =
                `${(Math.sin(theta/2) * Math.cos(phi)).toFixed(3)}|1‚ü©`;

            const thetaStr = theta === Math.PI/2 ? 'œÄ/2' :
                           theta === Math.PI ? 'œÄ' :
                           theta === 0 ? '0' :
                           theta.toFixed(3);
            const phiStr = phi === Math.PI/2 ? 'œÄ/2' :
                         phi === Math.PI ? 'œÄ' :
                         phi === 0 ? '0' :
                         phi.toFixed(3);

            document.getElementById('thetaDisplay').textContent = thetaStr;
            document.getElementById('phiDisplay').textContent = phiStr;
        }

        class Complex {
            constructor(re, im) {
                this.re = re;
                this.im = im;
            }
            mult(scalar) {
                return new Complex(this.re * scalar, this.im * scalar);
            }
        }

        function setState(newTheta, newPhi) {
            theta = newTheta;
            phi = newPhi;
            document.getElementById('theta').value = theta;
            document.getElementById('phi').value = phi;
            updateState();
        }

        function applyGate(gate) {
            switch(gate) {
                case 'X':  // Pauli X (bit flip)
                    theta = Math.PI - theta;
                    phi = phi + Math.PI;
                    break;
                case 'Y':  // Pauli Y
                    theta = Math.PI - theta;
                    break;
                case 'Z':  // Pauli Z (phase flip)
                    phi = phi + Math.PI;
                    break;
                case 'H':  // Hadamard
                    const oldTheta = theta;
                    theta = Math.acos(Math.sin(oldTheta/2) * Math.cos(phi));
                    phi = Math.PI/2;
                    break;
                case 'S':  // S gate (œÄ/2 phase)
                    phi = phi + Math.PI/2;
                    break;
                case 'T':  // T gate (œÄ/4 phase)
                    phi = phi + Math.PI/4;
                    break;
                case 'RX':  // Rotate around X
                    theta = theta + Math.PI/4;
                    break;
                case 'RY':  // Rotate around Y
                    const cos = Math.cos(Math.PI/8);
                    const sin = Math.sin(Math.PI/8);
                    const newTheta = 2 * Math.acos(cos * Math.cos(theta/2) - sin * Math.sin(theta/2) * Math.sin(phi));
                    theta = newTheta;
                    break;
            }

            // Normalize angles
            while (phi > 2 * Math.PI) phi -= 2 * Math.PI;
            while (phi < 0) phi += 2 * Math.PI;
            while (theta > Math.PI) theta = 2 * Math.PI - theta;
            while (theta < 0) theta = -theta;

            document.getElementById('theta').value = theta;
            document.getElementById('phi').value = phi;
            updateState();
        }

        function toggleRotation() {
            autoRotate = !autoRotate;
        }

        function animate(mode) {
            if (animationMode === mode) {
                animationMode = null;
                return;
            }
            animationMode = mode;
            animationTime = 0;
        }

        function gameLoop() {
            if (autoRotate) {
                rotation += 0.01;
            }

            if (animationMode) {
                animationTime += 0.05;

                switch(animationMode) {
                    case 'orbit':
                        phi = animationTime;
                        break;
                    case 'wiggle':
                        theta = Math.PI/2 + Math.sin(animationTime) * 0.5;
                        phi = animationTime * 0.5;
                        break;
                    case 'random':
                        if (Math.random() < 0.1) {
                            theta += (Math.random() - 0.5) * 0.3;
                            phi += (Math.random() - 0.5) * 0.3;
                            theta = Math.max(0, Math.min(Math.PI, theta));
                        }
                        break;
                }

                document.getElementById('theta').value = theta;
                document.getElementById('phi').value = phi;
                updateDisplay();
            }

            drawSphere();
            requestAnimationFrame(gameLoop);
        }

        // Initialize
        updateState();
        gameLoop();

        // Easter egg: Click sphere to randomize
        canvas.addEventListener('click', () => {
            theta = Math.random() * Math.PI;
            phi = Math.random() * 2 * Math.PI;
            document.getElementById('theta').value = theta;
            document.getElementById('phi').value = phi;
            updateState();
        });
    </script>
</body>
</html>
